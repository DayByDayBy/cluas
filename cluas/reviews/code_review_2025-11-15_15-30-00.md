# Code Review: Corvid Council (Third Pass)

**Date:** 2025-11-15

## a) High-Level Summary

This review assesses the "Cluas" repository against the detailed "Corvid Council - Development Guide." The document clarifies that the project is a multi-agent system ("Corvid Council") for a hackathon, with a clear vision, architecture, and development plan. The goal is a Gradio-based group chat of four AI crow experts (Corvus, Magpie, Raven, Crow) that also exposes its functionality as a set of external MCP tools.

The current codebase represents a very early stage of this vision. It has established a foundational piece of the `Corvus` character and the `AgentMemory` system, which aligns with the "Week 1: Days 1-2" goals of the development plan. However, the implementation is still far from the complete architecture described in the guide. The existing code provides a skeleton for one character's tools but does not yet include the orchestration, multi-agent interaction, or the dual Gradio/MCP interface that are central to the project concept.

## b) Detailed Description of Components vs. Project Plan

### Current Implementation vs. "Week 1: Days 1-2" Goals

The development guide sets a clear goal for the first two days: "One character working with tools in Gradio." Let's see how the current code stacks up.

-   **`Corvus` Character:** The `src/characters/corvus.py` file lays the groundwork for the "Scholar" archetype. Its `search_papers` function, with its fallback logic (PubMed -> Semantic Scholar -> arXiv), aligns perfectly with the described perfectionist, citation-focused personality. The integration with `AgentMemory` to log findings is a direct implementation of the cross-agent context recall mentioned in the guide.
-   **`AgentMemory`:** The `src/cluas_mcp/common/memory.py` is a solid first pass at the "agent-memory subsystem." It supports adding items with metadata (`mentioned_by`, `tags`) and retrieving them, which is the core requirement for enabling cross-agent context.
-   **API Clients:** The `src/cluas_mcp/common/api_clients.py` file contains the stubs for the clients Corvus needs. The `ArxivClient` is functional, which allows for some level of testing, while the others are placeholders. This is consistent with the iterative approach of getting one part working first.
-   **Missing Components:** Crucially, several key components from the development guide are entirely absent from the current codebase:
    -   **`CouncilOrchestrator`**: There is no orchestrator to manage conversation flow or facilitate discussion between agents.
    -   **`Character` Base Class**: The `CorvusMCP` class is standalone; it does not inherit from a common `Character` base class.
    -   **Gradio Interface**: The `gradio/app.py` is empty. There is no UI to interact with Corvus.
    -   **MCP Tool Exposure**: There is no code to expose the `ask_crow_council` or other external MCP tools.

In summary, the current code has started implementing the `Corvus` character's internal logic but has not yet built the framework (orchestrator, base classes, UI) that will allow it to function as part of the "Corvid Council."

## c) Opinionated Breakdown, Expectations, and Suggestions

The development guide is excellent and provides a clear roadmap. The "roughness" of the current code is perfectly understandable in this context. The focus has clearly been on prototyping a single agent's core behavior, which is a sensible way to start.

### Alignment with Vision

-   **Good:** The `CorvusMCP` and `AgentMemory` components are well-aligned with the project's vision. The idea of logging findings to a shared memory is a strong foundation for the multi-agent system.
-   **Gap:** The current file structure does not match the target structure outlined in the guide. For example, the tools are not yet separated into `src/mcp/tools/`, and there is no `orchestrator.py` or `character.py`.

### Actionable Suggestions for Next Steps

Given the detailed plan, my suggestions are to follow it closely. Here is a prioritized list of actions to bridge the gap between the current code and the "Week 1" goals:

1.  **Establish the Target File Structure:** Before writing more code, refactor the existing files to match the structure in the development guide. This will make the project much easier to navigate and build upon.
    -   Create `src/orchestrator.py`, `src/character.py`, and `src/mcp/tools/academic.py`.
    -   Move the `CorvusMCP` logic into `src/characters/corvus.py` and make it inherit from a new `Character` base class in `src/character.py`.
    -   Move the API client logic into the appropriate tool files (e.g., `academic.py`).
    -   Move the experimental scripts (`blah.py`, etc.) to an `/experimental` directory as planned.

2.  **Implement the `CouncilOrchestrator` Skeleton:** Create the `CouncilOrchestrator` class with placeholder methods as described in the guide. This will be the central hub of the application.

3.  **Build a Basic Gradio UI:** Implement a minimal version of the Gradio interface. The goal for "Days 1-2" is to be able to ask a question and see Corvus respond. This will involve:
    -   Creating the chat UI in `src/ui/interface.py`.
    -   Wiring the UI to the `CouncilOrchestrator`.
    -   Having the orchestrator call the `Corvus` character.

4.  **Fix the Broken Import:** The `formatting.py` file is still empty, which blocks `CorvusMCP` from running. Implement the `snippet_abstract` and `format_authors` functions so the character's output can be displayed.

5.  **Write Tests:** As you build these components, write basic unit tests as planned. A test for the `AgentMemory` and a simple integration test for the orchestrator calling Corvus would be a great start.

### Future Expectations

Following the development guide, I expect to see the project evolve rapidly. After establishing the core framework and getting Corvus to respond in the UI, the next logical steps will be to add the `Magpie` character and implement the staggered, interactive conversation flow described in the guide.

The project is ambitious for a hackathon, but the detailed plan makes it achievable. The key will be to follow the phased approach, ensuring each component is functional before moving to the next. The current code is a good, albeit small, first step on that path.
